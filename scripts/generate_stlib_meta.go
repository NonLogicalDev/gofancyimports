package main

import (
	"fmt"
	"os"
	"sort"

	xstdlib "github.com/NonLogicalDev/gofancyimports/internal/stdlib/go_x_stdlib"
)

func main() {
	// Collect all unique versions
	versionSet := make(map[xstdlib.Version]bool)
	
	// Loop over all packages and their symbols
	for _, symbols := range xstdlib.PackageSymbols {
		for _, symbol := range symbols {
			versionSet[symbol.Version] = true
		}
	}
	
	// Convert to slice and sort
	versions := make([]xstdlib.Version, 0, len(versionSet))
	for v := range versionSet {
		versions = append(versions, v)
	}
	
	// Sort versions (they're int8, so numeric sort works)
	sort.Slice(versions, func(i, j int) bool {
		return versions[i] < versions[j]
	})
	
	// Generate the output file
	output := `// Code generated by scripts/generate_stlib_meta.go. DO NOT EDIT.

package stdlib

// BootstrapVersion is the Go version used during toolchain bootstrapping.
const BootstrapVersion = ` + fmt.Sprintf("%q", xstdlib.BootstrapVersion.String()) + `

// SupportedVersions contains all Go versions covered by the stdlib metadata.
var SupportedVersions = []string{
`
	
	for _, v := range versions {
		output += fmt.Sprintf("\t%q,\n", v.String())
	}
	
	output += "}\n"
	
	// Write to file
	if err := os.WriteFile("internal/stdlib/xxx_metadata.go", []byte(output), 0644); err != nil {
		fmt.Fprintf(os.Stderr, "Error writing file: %v\n", err)
		os.Exit(1)
	}
	
	fmt.Printf("Generated internal/stdlib/xxx_metadata.go with %d versions\n", len(versions))
}

